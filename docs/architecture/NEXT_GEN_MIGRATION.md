
# üöÄ Ada Stargate v4.0: The "Big 3" Architecture Migration

**Reference Philosophy:** [Big 3 Super Agent](https://github.com/disler/big-3-super-agent) | [Beyond MCP](https://github.com/disler/beyond-mcp)

## 1. The Core Shift
We are transitioning from a **Monolithic Frontend Orchestrator** (current React App) to a **Federated Multi-Agent Backend** (Python/FastAPI).

The goal is **"Zero Error"** via specialized agents running in isolated environments (Sandboxes), communicating via a strictly typed protocol (MCP).

---

## 2. The "Big 3" Hierarchy for Ada

### üß† Level 1: The ORCHESTRATOR (Router)
*   **Identity:** `ada.marina.wim`
*   **Technology:** **LangGraph** + **Gemini 1.5 Pro**
*   **Role:** The "State Machine". It does not perform tasks. It maintains the *Global Context* and routes intents.
*   **Logic:**
    1.  Receives user prompt.
    2.  Determines active nodes needed (e.g., `[Finance, Legal]`).
    3.  Updates the State Graph.
    4.  Dispatches tasks to Level 2.

### üëî Level 2: The EXPERTS (MCP Servers)
*   **Identity:** `ada.finance`, `ada.legal`, `ada.technic`, `ada.sea`
*   **Technology:** **FastMCP** (Python)
*   **Role:** Domain Experts. They expose "Tools" to the Orchestrator but possess their own internal reasoning loops.
*   **Architecture:** Each Expert is an independent MCP Server.
    *   *Benefit:* `ada.finance` can crash without killing `ada.legal`.
    *   *Benefit:* `ada.legal` cannot hallucinate financial data because it has no access to that database.

### üõ†Ô∏è Level 3: The WORKERS (Sandboxed Execution)
*   **Identity:** "Code Interpreter", "Analysis Bot", "Scraper"
*   **Technology:** **Pydantic AI** + **Docker / E2B Sandboxes**
*   **Role:** The "Hands". They execute code generated by the Experts.
*   **Pattern:** **"Code-First"**. Instead of the LLM trying to calculate a penalty fee mathematically (where it might fail), the Expert writes a Python script:
    ```python
    # ada.finance writes this code:
    def calculate_penalty(days, rate):
        return days * rate * 1.2 # Standard logic
    ```
    The Worker executes this in a sandbox and returns the exact result. **Zero Hallucination.**

---

## 3. Tech Stack Mapping (Current vs Future)

| Component | Current (v3.2 - Typescript) | Future (v4.0 - Python Enterprise) |
| :--- | :--- | :--- |
| **Orchestrator** | `orchestratorService.ts` (Regex/If-Else) | **LangGraph** (Stateful Graph) |
| **Agents** | `services/agents/*.ts` (In-memory objects) | **FastMCP Servers** (Independent Processes) |
| **Data Models** | `types.ts` (Interfaces) | **Pydantic Models** (Runtime Validation) |
| **Memory** | React State (Transient) | **PostgreSQL** (Entity) + **Redis** (State) |
| **Knowledge** | JSON / Markdown Strings | **Qdrant** (Vector DB) + **RAG** |
| **Execution** | Browser JS Engine | **Secure Linux Sandbox** (Docker) |

---

## 4. Migration Strategy: "Strangler Fig" Pattern

We will not delete the frontend. We will replace the internals piece by piece.

**Phase 1: The Bridge**
1.  Spin up a **FastAPI** server.
2.  Create the first **FastMCP** server for `ada.finance`.
3.  Modify `financeAgent.ts` in React to stop calculating locally and instead call `POST /api/finance/invoice`.

**Phase 2: The Brain Transplant**
1.  Implement **LangGraph** on the backend.
2.  Point the React Chat Interface to stream responses from LangGraph.

**Phase 3: Full Autonomy**
1.  Deploy **Qdrant** for `ada.legal`.
2.  Enable **Self-Correction Loops** (if an agent fails, LangGraph retries with a new strategy).

---

## 5. Why this achieves "Zero Error"?
1.  **Type Safety:** Pydantic ensures input/output is exactly what is expected.
2.  **Code Execution:** Mathematical and logical tasks are solved by Python code, not LLM probability tokens.
3.  **Isolation:** Errors are contained within a single node/sandbox and retried automatically.
